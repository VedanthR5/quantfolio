[
  {
    "objectID": "tutorials/arima_fundamentals.html",
    "href": "tutorials/arima_fundamentals.html",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "",
    "text": "A Step-by-Step Guide to Predicting AAPL Stock Prices"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#what-is-arima",
    "href": "tutorials/arima_fundamentals.html#what-is-arima",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "What is ARIMA?",
    "text": "What is ARIMA?\nARIMA (AutoRegressive Integrated Moving Average) is a popular statistical model for time series forecasting. It combines three components:\n\nAR (AutoRegressive): Uses past values to predict future values\nI (Integrated): Differencing to make non-stationary data stationary\nMA (Moving Average): Uses past forecast errors in the prediction\n\n\nARIMA Parameters (p, d, q)\n\n\n\nParameter\nDescription\nHow to Choose\n\n\n\n\np\nNumber of lag observations (AR terms)\nUse PACF plot\n\n\nd\nDegree of differencing\nUse ADF test\n\n\nq\nSize of moving average window\nUse ACF plot\n\n\n\n\n\nWhy Use ARIMA for Stock Prices?\n\nStock prices exhibit trends (non-stationary behavior)\nARIMA can handle trends through differencing\nWalk-forward validation simulates real trading scenarios\nProvides interpretable forecasts\n\n\nAuthor: Vedanth Ramanathan Repository: vr-quantfolio-intro"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#import-dependencies",
    "href": "tutorials/arima_fundamentals.html#import-dependencies",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "1. Import Dependencies",
    "text": "1. Import Dependencies\n\n# Core data manipulation and numerical computing\nimport pandas as pd\nimport numpy as np\n\n# Visualization libraries\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Financial data\nimport yfinance as yf\n\n# Statistical tests and models\nfrom statsmodels.tsa.stattools import adfuller, acf, pacf\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.arima.model import ARIMA\n\n# Machine learning metrics\nfrom sklearn.metrics import mean_squared_error\n\n# Suppress warnings for cleaner output\nimport warnings\nwarnings.filterwarnings('ignore')\n\nprint(\"All dependencies imported successfully.\")"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#load-stock-data",
    "href": "tutorials/arima_fundamentals.html#load-stock-data",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "2. Load Stock Data",
    "text": "2. Load Stock Data\nWe’ll download AAPL (Apple Inc.) stock data from Yahoo Finance spanning from 2010 to 2025. This gives us approximately 15 years of daily trading data.\n\n# Define stock parameters\nstock = \"AAPL\"\nstart_date = \"2010-12-20\"\nend_date = \"2025-12-30\"\n\n# Download stock data from Yahoo Finance\n# auto_adjust=False keeps original OHLC prices (not adjusted for splits/dividends)\n# multi_level_index=False gives us simple column names\ndf = yf.download(\n    stock, \n    start=start_date, \n    end=end_date, \n    auto_adjust=False, \n    multi_level_index=False\n)\n\n# Check for and remove any missing values\nprint(f\"Missing values: {df.isnull().values.any()}\")\ndf = df.dropna()\n\n# Display basic info\nprint(f\"\\n{stock} Stock Data Summary:\")\nprint(f\"   Date Range: {df.index.min().date()} to {df.index.max().date()}\")\nprint(f\"   Trading Days: {len(df):,}\")\nprint(f\"   Columns: {list(df.columns)}\")\n\n# Show first few rows\ndf.head()"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#exploratory-data-analysis-eda",
    "href": "tutorials/arima_fundamentals.html#exploratory-data-analysis-eda",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "3. Exploratory Data Analysis (EDA)",
    "text": "3. Exploratory Data Analysis (EDA)\nLet’s visualize the stock price to understand its behavior over time. We’ll focus on the Close price, which is what we’ll be forecasting.\n\n# Create interactive price chart with Plotly\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=df.index, \n    y=df['Close'],\n    mode='lines',\n    name='Close Price',\n    line=dict(color='#2196F3', width=1.5)\n))\n\nfig.update_layout(\n    title=f'{stock} Stock Price History',\n    xaxis_title='Date',\n    yaxis_title='Price (USD)',\n    template='plotly_white',\n    height=500,\n    hovermode='x unified'\n)\n\nfig.show()"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#traintest-split",
    "href": "tutorials/arima_fundamentals.html#traintest-split",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "4. Train/Test Split",
    "text": "4. Train/Test Split\nFor time series data, we cannot use random splits because the order of observations matters. We split chronologically: - Training Set (80%): Historical data the model learns from - Test Set (20%): Recent data to evaluate predictions\n\n# Split data: 80% training, 20% testing\ntrain_size = int(len(df) * 0.8)\n\ntrain = df['Close'][:train_size]\ntest = df['Close'][train_size:]\n\nprint(f\"Training Set: {len(train):,} observations\")\nprint(f\"   From: {train.index.min().date()} to {train.index.max().date()}\")\nprint(f\"\\nTest Set: {len(test):,} observations\")\nprint(f\"   From: {test.index.min().date()} to {test.index.max().date()}\")\n\n# Visualize the split\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=train.index, y=train.values,\n    mode='lines', name='Training Data',\n    line=dict(color='#4CAF50', width=1.5)\n))\n\nfig.add_trace(go.Scatter(\n    x=test.index, y=test.values,\n    mode='lines', name='Test Data',\n    line=dict(color='#FF5722', width=1.5)\n))\n\nfig.update_layout(\n    title='Train/Test Split Visualization',\n    xaxis_title='Date',\n    yaxis_title='Close Price (USD)',\n    template='plotly_white',\n    height=450\n)\n\nfig.show()"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#testing-for-stationarity",
    "href": "tutorials/arima_fundamentals.html#testing-for-stationarity",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "5. Testing for Stationarity",
    "text": "5. Testing for Stationarity\nARIMA requires stationary data, meaning: - Constant mean over time - Constant variance over time - No seasonal patterns\nWe use the Augmented Dickey-Fuller (ADF) Test: - H₀ (Null): The series has a unit root (non-stationary) - H₁ (Alternative): The series is stationary\nIf p-value &lt; 0.05, we reject H₀ and conclude the series is stationary.\n\n# Function to perform ADF test and display results\ndef adf_test(series, title=''):\n    \"\"\"\n    Perform Augmented Dickey-Fuller test for stationarity.\n    \n    Returns:\n        bool: True if stationary (p &lt; 0.05), False otherwise\n    \"\"\"\n    result = adfuller(series.dropna())\n    \n    print(f\"ADF Test Results {title}\")\n    print(\"-\" * 40)\n    print(f\"   Test Statistic: {result[0]:.4f}\")\n    print(f\"   P-Value: {result[1]:.6f}\")\n    print(f\"   Lags Used: {result[2]}\")\n    print(f\"   Observations: {result[3]}\")\n    print(\"\\n   Critical Values:\")\n    for key, value in result[4].items():\n        print(f\"      {key}: {value:.4f}\")\n    \n    is_stationary = result[1] &lt; 0.05\n    print(f\"\\n   Conclusion: {'STATIONARY' if is_stationary else 'NON-STATIONARY'}\")\n    \n    return is_stationary\n\n# Test original price series\nprint(\"Testing ORIGINAL Close Prices:\\n\")\nis_original_stationary = adf_test(train, title='(Original Prices)')"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#differencing-making-data-stationary",
    "href": "tutorials/arima_fundamentals.html#differencing-making-data-stationary",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "6. Differencing: Making Data Stationary",
    "text": "6. Differencing: Making Data Stationary\nSince stock prices are non-stationary (they trend upward/downward), we apply differencing:\n\\[X'_t = X_t - X_{t-1}\\]\nThis transforms prices into daily changes, which fluctuate around zero and are typically stationary.\nWhy this works: - Original: [100, 102, 105, 103, 108] → Trending up - Differenced: [+2, +3, -2, +5] → Fluctuates around zero\n\n# Apply differencing to training data\n# diff() computes: current_value - previous_value\ntrain_diff = train.diff().dropna()\n\n# Visualize before and after differencing\nfig, axes = plt.subplots(2, 1, figsize=(14, 8))\n\n# Original prices\naxes[0].plot(train.index, train.values, color='#2196F3', linewidth=1)\naxes[0].set_title('Original Prices (Non-Stationary)', fontsize=12, fontweight='bold')\naxes[0].set_xlabel('Date')\naxes[0].set_ylabel('Price (USD)')\naxes[0].grid(True, alpha=0.3)\n\n# Differenced prices\naxes[1].plot(train_diff.index, train_diff.values, color='#4CAF50', linewidth=0.8)\naxes[1].axhline(y=0, color='red', linestyle='--', alpha=0.7, label='Zero Line')\naxes[1].set_title('Differenced Prices (Stationary)', fontsize=12, fontweight='bold')\naxes[1].set_xlabel('Date')\naxes[1].set_ylabel('Daily Change (USD)')\naxes[1].legend()\naxes[1].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n# Test if differenced series is stationary\nprint(\"\\n\" + \"=\"*50)\nprint(\"Testing DIFFERENCED Close Prices:\\n\")\nis_diff_stationary = adf_test(train_diff, title='(Differenced Prices)')"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#arima-model-training",
    "href": "tutorials/arima_fundamentals.html#arima-model-training",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "7. ARIMA Model Training",
    "text": "7. ARIMA Model Training\nNow we’ll train an ARIMA model with: - p = 1: One autoregressive term (uses 1 past value) - d = 2: Two levels of differencing (ARIMA applies its own differencing) - q = 1: One moving average term\n\nWalk-Forward Validation\nInstead of training once and predicting all test data, we use walk-forward validation: 1. Train on all available historical data 2. Predict the next day 3. Add that actual value to training set 4. Retrain and repeat\nThis mimics real-world trading where you retrain models as new data arrives.\n\n# Prepare data for walk-forward validation\n# history: growing list of training observations (starts with full train set)\nhistory = train.tolist()\n\n# predictions: will store our model's forecasts for each test observation\npredictions = []\n\n# ARIMA parameters\norder = (1, 2, 1)  # (p, d, q)\n\nprint(f\"Starting Walk-Forward ARIMA Training\")\nprint(f\"   Order: {order}\")\nprint(f\"   Test observations to predict: {len(test)}\")\nprint(\"-\" * 50)\n\n# Walk-forward validation loop\n# For each day in test set: train model, predict, add actual, repeat\nfor t in range(len(test)):\n    # Train ARIMA model on all historical data available so far\n    model = ARIMA(history, order=order)\n    model_fit = model.fit()\n    \n    # Forecast the next day's price\n    # forecast() returns an array, we take the first (only) element\n    yhat = model_fit.forecast()[0]\n    predictions.append(yhat)\n    \n    # Add the ACTUAL observed value to history for next iteration\n    # This is key: we're NOT adding our prediction, but the real value\n    actual = test.iloc[t]\n    history.append(actual)\n    \n    # Progress update every 100 iterations\n    if (t + 1) % 100 == 0 or t == 0:\n        print(f\"   Completed {t + 1}/{len(test)} predictions\")\n\nprint(f\"\\nTraining complete. Generated {len(predictions)} predictions.\")"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#understanding-the-cumulative-sum-reversal",
    "href": "tutorials/arima_fundamentals.html#understanding-the-cumulative-sum-reversal",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "8. Understanding the Cumulative Sum Reversal",
    "text": "8. Understanding the Cumulative Sum Reversal\n⚠️ Critical Concept: ARIMA with d=2 works on twice-differenced data. Its predictions are in “change-of-changes” space, NOT actual prices!\n\nThe Problem\n\nRaw ARIMA predictions: Changes in changes (meaningless for trading)\nWhat we need: Actual price predictions\n\n\n\nThe Solution: Cumulative Sum (cumsum)\nSince differencing = subtraction, the inverse is cumulative sum (adding up).\nExample:\nOriginal prices:     [100, 102, 105, 103, 108]\n1st diff (changes):  [+2, +3, -2, +5]\n2nd diff (Δchanges): [+1, -5, +7]\n\nTo reverse:\ncumsum([+1, -5, +7]) → [+1, -4, +3] ≈ 1st diff\ncumsum([+2, +1, -4, +3]) → [2, 3, -1, 2] ... needs anchor!\nWe anchor the cumsum at the last known training price to get actual predictions.\n\n# ============================================================\n# STEP 1: Apply differencing to test data (for comparison)\n# ============================================================\n# We difference test data to get \"changes\" which ARIMA predicts\ntest_diff = test.diff().dropna()\n\n# ============================================================\n# STEP 2: Convert predictions to pandas Series with proper index\n# ============================================================\n# predictions list -&gt; Series aligned with test dates\npredictions_series = pd.Series(predictions, index=test.index)\n\n# Difference the predictions too (since ARIMA predicts d=2 space)\npredictions_diff = predictions_series.diff().dropna()\n\n# ============================================================\n# STEP 3: Cumulative sum reversal - THE KEY STEP\n# ============================================================\n# cumsum() reverses differencing by accumulating the changes\n# But we need an anchor point - the last known price before test period\n\n# Get the anchor: last training price\nanchor_price = train.iloc[-1]\nprint(f\"Anchor price (last training value): ${anchor_price:.2f}\")\n\n# Reverse the differencing for ACTUAL test values\n# cumsum() accumulates: [a, b, c] -&gt; [a, a+b, a+b+c]\n# Adding anchor shifts the whole series to correct price level\nreverse_test_diff = test_diff.cumsum() + anchor_price\n\n# Reverse the differencing for PREDICTED values\nreverse_predictions = predictions_diff.cumsum() + anchor_price\n\nprint(f\"\\nReversed {len(reverse_predictions)} predictions back to price space.\")"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#error-calculation",
    "href": "tutorials/arima_fundamentals.html#error-calculation",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "9. Error Calculation",
    "text": "9. Error Calculation\nWe evaluate model performance using two metrics:\n\nMean Squared Error (MSE)\n\\[MSE = \\frac{1}{n}\\sum_{i=1}^{n}(y_i - \\hat{y}_i)^2\\] - Penalizes large errors heavily (squared) - Lower is better\n\n\nSymmetric Mean Absolute Percentage Error (SMAPE)\n\\[SMAPE = \\frac{100\\%}{n}\\sum_{i=1}^{n}\\frac{|y_i - \\hat{y}_i|}{(|y_i| + |\\hat{y}_i|)/2}\\] - Scale-independent (percentage) - Ranges from 0% (perfect) to 200% (terrible) - Symmetric: treats over/under-prediction equally\n\n# ============================================================\n# FINAL STEP: Calculate prediction error metrics\n# ============================================================\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\n\n# Align the series (they should match but let's be safe)\n# Use intersection of indices\ncommon_index = reverse_test_diff.index.intersection(reverse_predictions.index)\nactual = reverse_test_diff.loc[common_index]\npredicted = reverse_predictions.loc[common_index]\n\n# Calculate metrics\nmae = mean_absolute_error(actual, predicted)\nrmse = np.sqrt(mean_squared_error(actual, predicted))\nmape = np.mean(np.abs((actual - predicted) / actual)) * 100\n\nprint(\"Prediction Error Metrics\")\nprint(\"=\" * 40)\nprint(f\"Mean Absolute Error (MAE):     ${mae:.2f}\")\nprint(f\"Root Mean Squared Error (RMSE): ${rmse:.2f}\")\nprint(f\"Mean Absolute % Error (MAPE):  {mape:.2f}%\")\n\nprint(\"\\nInterpretation\")\nprint(\"-\" * 40)\nprint(f\"On average, predictions were off by ${mae:.2f}\")\nprint(f\"This represents a {mape:.1f}% error rate\")\n\nif mape &lt; 5:\n    print(\"Result: Excellent accuracy for stock prediction.\")\nelif mape &lt; 10:\n    print(\"Result: Good accuracy, usable for trend analysis.\")\nelse:\n    print(\"Result: Moderate accuracy - use with caution.\")"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#final-visualization-predictions-vs-actual",
    "href": "tutorials/arima_fundamentals.html#final-visualization-predictions-vs-actual",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "10. Final Visualization: Predictions vs Actual",
    "text": "10. Final Visualization: Predictions vs Actual\nLet’s visualize how well our ARIMA model performed:\n\n# Create comprehensive visualization\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=(\n        'Full Price History with Predictions',\n        'Test Period: Actual vs Predicted',\n        'Prediction Errors Over Time',\n        'Error Distribution'\n    ),\n    vertical_spacing=0.12,\n    horizontal_spacing=0.1\n)\n\n# ---- Plot 1: Full history ----\nfig.add_trace(\n    go.Scatter(x=train.index, y=train.values, name='Training Data',\n               line=dict(color='#2196F3', width=1)),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=actual_prices.index, y=actual_prices.values, name='Actual (Test)',\n               line=dict(color='#4CAF50', width=1.5)),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=predicted_prices.index, y=predicted_prices.values, name='Predicted',\n               line=dict(color='#FF5722', width=1.5, dash='dash')),\n    row=1, col=1\n)\n\n# ---- Plot 2: Zoomed test period ----\nfig.add_trace(\n    go.Scatter(x=actual_prices.index, y=actual_prices.values, name='Actual',\n               line=dict(color='#4CAF50', width=2), showlegend=False),\n    row=1, col=2\n)\nfig.add_trace(\n    go.Scatter(x=predicted_prices.index, y=predicted_prices.values, name='Predicted',\n               line=dict(color='#FF5722', width=2, dash='dash'), showlegend=False),\n    row=1, col=2\n)\n\n# ---- Plot 3: Errors over time ----\nerrors = actual_prices - predicted_prices\nfig.add_trace(\n    go.Scatter(x=errors.index, y=errors.values, name='Error',\n               line=dict(color='#9C27B0', width=1), showlegend=False),\n    row=2, col=1\n)\nfig.add_hline(y=0, line_dash=\"dash\", line_color=\"red\", row=2, col=1)\n\n# ---- Plot 4: Error distribution ----\nfig.add_trace(\n    go.Histogram(x=errors.values, nbinsx=50, name='Error Distribution',\n                 marker_color='#9C27B0', showlegend=False),\n    row=2, col=2\n)\n\n# Update layout\nfig.update_layout(\n    height=800,\n    title_text=f'ARIMA({order[0]},{order[1]},{order[2]}) Model Performance on {stock}',\n    template='plotly_white',\n    showlegend=True,\n    legend=dict(x=0.02, y=0.98)\n)\n\nfig.update_xaxes(title_text='Date', row=1, col=1)\nfig.update_xaxes(title_text='Date', row=1, col=2)\nfig.update_xaxes(title_text='Date', row=2, col=1)\nfig.update_xaxes(title_text='Error ($)', row=2, col=2)\n\nfig.update_yaxes(title_text='Price ($)', row=1, col=1)\nfig.update_yaxes(title_text='Price ($)', row=1, col=2)\nfig.update_yaxes(title_text='Error ($)', row=2, col=1)\nfig.update_yaxes(title_text='Count', row=2, col=2)\n\nfig.show()"
  },
  {
    "objectID": "tutorials/arima_fundamentals.html#key-takeaways",
    "href": "tutorials/arima_fundamentals.html#key-takeaways",
    "title": "ARIMA Time Series Forecasting for Stock Prices",
    "section": "11. Key Takeaways",
    "text": "11. Key Takeaways\n\nWhat We Learned:\n\nStationarity is Essential: ARIMA requires stationary data. Stock prices are non-stationary, so we use differencing.\nThe ARIMA Process:\n\np (AR): How many past values influence the current value\nd (I): How many times to difference the data\nq (MA): How many past forecast errors influence the current forecast\n\nWalk-Forward Validation: More realistic than train-once-predict-all because it mimics real trading conditions.\nCumulative Sum Reversal: Essential to convert ARIMA’s difference-space predictions back to actual prices.\nModel Limitations:\n\nARIMA assumes linear relationships\nCan’t capture complex patterns or external factors\nStock prices are notoriously hard to predict!\n\n\n\n\nNext Steps:\n\nTry different (p, d, q) parameters\nUse auto_arima from pmdarima for automatic parameter selection\nExplore SARIMA for seasonal data\nCompare with machine learning approaches (LSTM, Prophet)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VR Quantfolio",
    "section": "",
    "text": "This site hosts interactive tutorials on quantitative finance with Python.\n\n\n\n\nLearn how to forecast stock prices using the ARIMA model:\n\nStationarity testing with the ADF test\nDifferencing transformations\nWalk-forward validation\nCumulative sum reversal\nError metrics (MSE, SMAPE)\n\n\n\n\n\nWant to try these concepts hands-on? Check out the Streamlit app:\n\n\n\nOpen in Streamlit\n\n\nFeatures include:\n\nStock data fetching and visualization\nAutoML model training with PyCaret\nARIMA and NeuralProphet forecasting\nPortfolio optimization\n\n\n\n\n\n\n\n\n\n\n\nTopic\nDescription\n\n\n\n\nTime Series Analysis\nStationarity, differencing, autocorrelation\n\n\nARIMA Modeling\nAR, I, and MA components explained\n\n\nMachine Learning\nAutoML for stock prediction\n\n\nPortfolio Theory\nMean-variance optimization, efficient frontier\n\n\n\n\n\n\n\nPython: pandas, numpy, scipy\nVisualization: Plotly, matplotlib\nML/AI: PyCaret, statsmodels, NeuralProphet\nPortfolio: Riskfolio-Lib\nWeb: Streamlit\n\n\n\n\nAll code is available on GitHub:\n\n\n\nGitHub\n\n\n\n\nMade by Vedanth Ramanathan\nDocumentation · GitHub"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "VR Quantfolio",
    "section": "",
    "text": "This site hosts interactive tutorials on quantitative finance with Python.\n\n\n\n\nLearn how to forecast stock prices using the ARIMA model:\n\nStationarity testing with the ADF test\nDifferencing transformations\nWalk-forward validation\nCumulative sum reversal\nError metrics (MSE, SMAPE)\n\n\n\n\n\nWant to try these concepts hands-on? Check out the Streamlit app:\n\n\n\nOpen in Streamlit\n\n\nFeatures include:\n\nStock data fetching and visualization\nAutoML model training with PyCaret\nARIMA and NeuralProphet forecasting\nPortfolio optimization\n\n\n\n\n\n\n\n\n\n\n\nTopic\nDescription\n\n\n\n\nTime Series Analysis\nStationarity, differencing, autocorrelation\n\n\nARIMA Modeling\nAR, I, and MA components explained\n\n\nMachine Learning\nAutoML for stock prediction\n\n\nPortfolio Theory\nMean-variance optimization, efficient frontier\n\n\n\n\n\n\n\nPython: pandas, numpy, scipy\nVisualization: Plotly, matplotlib\nML/AI: PyCaret, statsmodels, NeuralProphet\nPortfolio: Riskfolio-Lib\nWeb: Streamlit\n\n\n\n\nAll code is available on GitHub:\n\n\n\nGitHub\n\n\n\n\nMade by Vedanth Ramanathan\nDocumentation · GitHub"
  }
]